/*
 * CLOUD API
 *
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * API version: 5.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ionossdk

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// LoadBalancerApiService LoadBalancerApi service
type LoadBalancerApiService service

// DatacentersLoadbalancersBalancednicsDeleteOpts Optional parameters for the method 'DatacentersLoadbalancersBalancednicsDelete'
type DatacentersLoadbalancersBalancednicsDeleteOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersBalancednicsDelete Detach a nic from loadbalancer
This will remove a nic from Load Balancer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param nicId The unique ID of the NIC
 * @param optional nil or *DatacentersLoadbalancersBalancednicsDeleteOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return map[string]interface{}
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersBalancednicsDelete(ctx _context.Context, datacenterId string, loadbalancerId string, nicId string, optionals *DatacentersLoadbalancersBalancednicsDeleteOpts) (map[string]interface{}, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics/{nicId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nicId"+"}", _neturl.PathEscape(parameterToString(nicId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersBalancednicsDelete",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersBalancednicsFindByNicOpts Optional parameters for the method 'DatacentersLoadbalancersBalancednicsFindByNic'
type DatacentersLoadbalancersBalancednicsFindByNicOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersBalancednicsFindByNic Retrieve a nic attached to Load Balancer
This will retrieve the properties of an attached nic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param nicId The unique ID of the NIC
 * @param optional nil or *DatacentersLoadbalancersBalancednicsFindByNicOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Nic
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersBalancednicsFindByNic(ctx _context.Context, datacenterId string, loadbalancerId string, nicId string, optionals *DatacentersLoadbalancersBalancednicsFindByNicOpts) (Nic, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Nic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics/{nicId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nicId"+"}", _neturl.PathEscape(parameterToString(nicId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersBalancednicsFindByNic",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersBalancednicsGetOpts Optional parameters for the method 'DatacentersLoadbalancersBalancednicsGet'
type DatacentersLoadbalancersBalancednicsGetOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersBalancednicsGet List Load Balancer Members 
You can retrieve a list of nics attached to a Load Balancer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param optional nil or *DatacentersLoadbalancersBalancednicsGetOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return BalancedNics
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersBalancednicsGet(ctx _context.Context, datacenterId string, loadbalancerId string, optionals *DatacentersLoadbalancersBalancednicsGetOpts) (BalancedNics, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BalancedNics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersBalancednicsGet",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersBalancednicsPostOpts Optional parameters for the method 'DatacentersLoadbalancersBalancednicsPost'
type DatacentersLoadbalancersBalancednicsPostOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersBalancednicsPost Attach a nic to Load Balancer
This will attach a pre-existing nic to a Load Balancer. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param nic Nic id to be attached
 * @param optional nil or *DatacentersLoadbalancersBalancednicsPostOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Nic
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersBalancednicsPost(ctx _context.Context, datacenterId string, loadbalancerId string, nic Nic, optionals *DatacentersLoadbalancersBalancednicsPostOpts) (Nic, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Nic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	// body params
	localVarPostBody = &nic
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersBalancednicsPost",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersDeleteOpts Optional parameters for the method 'DatacentersLoadbalancersDelete'
type DatacentersLoadbalancersDeleteOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersDelete Delete a Loadbalancer.
Removes the specific Loadbalancer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param optional nil or *DatacentersLoadbalancersDeleteOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return map[string]interface{}
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersDelete(ctx _context.Context, datacenterId string, loadbalancerId string, optionals *DatacentersLoadbalancersDeleteOpts) (map[string]interface{}, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersDelete",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersFindByIdOpts Optional parameters for the method 'DatacentersLoadbalancersFindById'
type DatacentersLoadbalancersFindByIdOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersFindById Retrieve a loadbalancer
Retrieves the attributes of a given Loadbalancer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param optional nil or *DatacentersLoadbalancersFindByIdOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Loadbalancer
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersFindById(ctx _context.Context, datacenterId string, loadbalancerId string, optionals *DatacentersLoadbalancersFindByIdOpts) (Loadbalancer, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Loadbalancer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersFindById",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersGetOpts Optional parameters for the method 'DatacentersLoadbalancersGet'
type DatacentersLoadbalancersGetOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersGet List Load Balancers
Retrieve a list of Load Balancers within the datacenter
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param optional nil or *DatacentersLoadbalancersGetOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Loadbalancers
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersGet(ctx _context.Context, datacenterId string, optionals *DatacentersLoadbalancersGetOpts) (Loadbalancers, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Loadbalancers
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersGet",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersPatchOpts Optional parameters for the method 'DatacentersLoadbalancersPatch'
type DatacentersLoadbalancersPatchOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersPatch Partially modify a Loadbalancer
You can use update attributes of a resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param loadbalancer Modified Loadbalancer
 * @param optional nil or *DatacentersLoadbalancersPatchOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Loadbalancer
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersPatch(ctx _context.Context, datacenterId string, loadbalancerId string, loadbalancer LoadbalancerProperties, optionals *DatacentersLoadbalancersPatchOpts) (Loadbalancer, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Loadbalancer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	// body params
	localVarPostBody = &loadbalancer
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersPatch",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersPostOpts Optional parameters for the method 'DatacentersLoadbalancersPost'
type DatacentersLoadbalancersPostOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersPost Create a Load Balancer
Creates a Loadbalancer within the datacenter
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancer Loadbalancer to be created
 * @param optional nil or *DatacentersLoadbalancersPostOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Loadbalancer
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersPost(ctx _context.Context, datacenterId string, loadbalancer Loadbalancer, optionals *DatacentersLoadbalancersPostOpts) (Loadbalancer, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Loadbalancer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	// body params
	localVarPostBody = &loadbalancer
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersPost",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

// DatacentersLoadbalancersPutOpts Optional parameters for the method 'DatacentersLoadbalancersPut'
type DatacentersLoadbalancersPutOpts struct {
    Pretty optional.Bool
    Depth optional.Int32
    XContractNumber optional.Int32
}

/*
DatacentersLoadbalancersPut Modify a Load Balancer
You can use update attributes of a resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param loadbalancerId The unique ID of the Load Balancer
 * @param loadbalancer Modified Loadbalancer
 * @param optional nil or *DatacentersLoadbalancersPutOpts - Optional Parameters:
 * @param "Pretty" (optional.Bool) -  Controls whether response is pretty-printed (with indentation and new lines)
 * @param "Depth" (optional.Int32) -  Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth=0: only direct properties are included. Children (servers etc.) are not included  - depth=1: direct properties and children references are included  - depth=2: direct properties and children properties are included  - depth=3: direct properties and children properties and children's children are included  - depth=... and so on
 * @param "XContractNumber" (optional.Int32) -  Users having more than 1 contract need to provide contract number, against which all API requests should be executed
@return Loadbalancer
*/
func (a *LoadBalancerApiService) DatacentersLoadbalancersPut(ctx _context.Context, datacenterId string, loadbalancerId string, loadbalancer Loadbalancer, optionals *DatacentersLoadbalancersPutOpts) (Loadbalancer, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Loadbalancer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(datacenterId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancerId"+"}", _neturl.PathEscape(parameterToString(loadbalancerId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if optionals != nil && optionals.Pretty.IsSet() {
		localVarQueryParams.Add("pretty", parameterToString(optionals.Pretty.Value(), ""))
	}
	if optionals != nil && optionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(optionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if optionals != nil && optionals.XContractNumber.IsSet() {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(optionals.XContractNumber.Value(), "")
	}
	// body params
	localVarPostBody = &loadbalancer
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersLoadbalancersPut",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}
